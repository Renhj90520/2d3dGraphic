import * as THREE from 'three';
import Cell from './cell';
import { randomInt, merge } from './utils';
import Tile from './Tile';
const TAU = Math.PI * 2;
const SQRT3 = Math.sqrt(3);
const DEG_TO_RAD = Math.PI / 180;
export class HexGrid {
  size = 5;
  cellSize = 10;
  type = GridType.HEX;
  cells = {};
  numCells = 0;
  extrudeSettings = {
    depth: 1,
    bevelEnabled: true,
    bevelSegments: 1,
    steps: 1,
    bevelSize: 0.5,
    bevelThickness: 0.5
  };
  autoGenerated = false;
  cellShape: THREE.Shape;
  cellGeo: THREE.Geometry;
  cellWidth: number;
  cellLength: number;
  hashDelimeter: string;
  directions: any[];
  diagonals: any[];
  list: any[];
  vec3: THREE.Vector3;
  cel: Cell;
  conversionVec: THREE.Vector3;
  geoCache: any[];
  matCache: any[];

  TWO_THIRDS = 2 / 3;
  cellShapeGeo: THREE.ShapeGeometry;
  constructor(size?, cellSize?) {
    this.size = size ? size : this.size;
    this.cellSize = cellSize ? cellSize : this.cellSize;

    const verts = [];
    for (let i = 0; i < 6; i++) {
      verts.push(this.createVertex(i));
    }

    this.cellShape = new THREE.Shape();
    this.cellShape.moveTo(verts[0].x, verts[0].y);
    for (let i = 1; i < 6; i++) {
      this.cellShape.lineTo(verts[i].x, verts[i].y);
    }
    this.cellShape.lineTo(verts[0].x, verts[0].y);
    this.cellShape.autoClose = true;

    this.cellGeo = new THREE.Geometry();
    this.cellGeo.vertices = verts;
    this.cellGeo.verticesNeedUpdate = true;

    this.cellShapeGeo = new THREE.ShapeGeometry(this.cellShape);

    this.cellWidth = this.cellSize * 2;
    this.cellLength = SQRT3 * 0.5 * this.cellWidth;
    this.hashDelimeter = '.';

    this.directions = [
      new Cell(1, -1, 0),
      new Cell(1, 0, -1),
      new Cell(0, 1, -1),
      new Cell(-1, 1, 0),
      new Cell(-1, 0, 1),
      new Cell(0, -1, 1)
    ];

    this.diagonals = [
      new Cell(2, -1, -1),
      new Cell(1, 1, -2),
      new Cell(-1, 2, -1),
      new Cell(-2, 1, 1),
      new Cell(-1, -1, 2),
      new Cell(1, -2, 1)
    ];

    this.list = [];
    this.vec3 = new THREE.Vector3();
    this.cel = new Cell();
    this.conversionVec = new THREE.Vector3();
    this.geoCache = [];
    this.matCache = [];
  }

  private createVertex(i) {
    const angle = (TAU / 6) * i;

    return new THREE.Vector3(
      this.cellSize * Math.cos(angle),
      this.cellSize * Math.sin(angle),
      0
    );
  }

  cellToPixel(cell) {
    this.vec3.x = cell.q * this.cellWidth * 0.75;
    this.vec3.y = cell.h;
    this.vec3.z = -((cell.s - cell.r) * this.cellLength * 0.5);
    return this.vec3;
  }

  pixelToCell(pos) {
    const q = pos.x * (this.TWO_THIRDS / this.cellSize);
    const r = (-pos.x / 3 + (SQRT3 / 3) * pos.z) / this.cellSize;
    this.cel.set(q, r, -q - r);
    return this.cubeRound(this.cel);
  }
  getCellAt(pos) {
    this.pixelToCell(pos);
    return this.cells[this.cellToHash(this.cel)];
  }

  getNeighbors(cell, diagonal, filter) {
    this.list.length = 0;
    for (let i = 0; i < this.directions.length; i++) {
      this.cel.copy(cell);
      this.cel.add(this.directions[i]);
      const c = this.cells[this.cellToHash(this.cel)];
      if (!c || (filter && !filter(cell, c))) {
        continue;
      }
      this.list.push(c);
    }

    if (diagonal) {
      for (let i = 0; i < this.directions.length; i++) {
        this.cel.copy(cell);
        this.cel.add(this.diagonals[i]);
        const c = this.cells[this.cellToHash(this.cel)];
        if (!c || (filter && filter(cell, c))) {
          continue;
        }
        this.list.push(c);
      }
    }

    return this.list;
  }
  getRandomCell() {
    let c,
      i = 0;
    const x = randomInt(0, this.numCells);
    for (c in this.cells) {
      if (i === x) {
        return this.cells[c];
      }
      i++;
    }
    return this.cells[c];
  }
  cellToHash(cel: Cell) {
    return cel.q + this.hashDelimeter + cel.r + this.hashDelimeter + cel.s;
  }
  distance(cellA, cellB) {
    let d = Math.max(
      Math.abs(cellA.q - cellB.q),
      Math.abs(cellA.r - cellB.r),
      Math.abs(cellA.s - cellB.s)
    );
    d += cellB.h - cellA.h;
    return d;
  }

  clearPath() {
    for (const i in this.cells) {
      const c: Cell = this.cells[i];
      c.clearPath();
    }
  }

  traverse(cb) {
    for (const i in this.cells) {
      cb(this.cells[i]);
    }
  }

  generateTile(cell, scale, material) {
    let height = Math.abs(cell.h);
    if (height < 1) height = 1;
    let geo = this.geoCache[height];
    if (!geo) {
      this.extrudeSettings.depth = height;
      geo = new THREE.ExtrudeGeometry(this.cellShape, this.extrudeSettings);
      this.geoCache[height] = geo;
    }

    const tile = new Tile({
      size: this.cellSize,
      scale,
      cell,
      geometry: geo,
      material: material
    });

    cell.tile = tile;
    return tile;
  }

  generateTiles(config?) {
    config = config || {};
    const tiles = [];
    let settings = {
      tileScale: 0.95,
      cellSize: this.cellSize,
      material: null,
      extrudeSettings: this.extrudeSettings
    };
    settings = merge(settings, config);

    this.cellSize = settings.cellSize;
    this.cellWidth = this.cellSize * 2;
    this.cellLength = SQRT3 * 0.5 * this.cellWidth;

    this.autoGenerated = true;
    this.extrudeSettings = settings.extrudeSettings;

    for (const i in this.cells) {
      const c = this.cells[i];
      const t = this.generateTile(c, settings.tileScale, settings.material);
      t.position.copy(this.cellToPixel(c));
      t.position.y = 0;
      tiles.push(t);
    }

    return tiles;
  }
  generateTilePoly(material?) {
    material = material || new THREE.MeshBasicMaterial({ color: 0x24b4ff });
    const mesh = new THREE.Mesh(this.cellShapeGeo, material);
    this.vec3.set(1, 0, 0);
    mesh.rotateOnAxis(this.vec3, Math.PI / 2);
    return mesh;
  }

  generate(config?) {
    config = config || {};
    this.size = typeof config.size === 'undefined' ? this.size : config.size;
    let x, y, z, c;
    for (let x = -this.size; x < this.size + 1; x++) {
      for (let y = -this.size; y < this.size + 1; y++) {
        z = -x - y;
        if (
          Math.abs(x) <= this.size &&
          Math.abs(y) <= this.size &&
          Math.abs(z) <= this.size
        ) {
          c = new Cell(x, y, z);
          this.add(c);
        }
      }
    }
  }
  generateOverlay(size, overlayObj, overlayMat) {
    let x, y, z;
    const geo = new THREE.Geometry().setFromPoints(this.cellShape.getPoints());
    for (let x = -size; x < size + 1; x++) {
      for (let y = -size; y < size + 1; y++) {
        z = -x - y;
        if (Math.abs(x) <= size && Math.abs(y) <= size && Math.abs(z) <= size) {
          this.cel.set(x, y, z);
          const line = new THREE.Line(geo, overlayMat);
          line.position.copy(this.cellToPixel(this.cel));
          line.rotation.x = 90 * DEG_TO_RAD;
          overlayObj.add(line);
        }
      }
    }
  }
  add(cell) {
    const h = this.cellToHash(cell);
    if (this.cells[h]) {
      return;
    }

    this.cells[h] = cell;
    this.numCells++;
    return cell;
  }
  remove(cell) {
    const h = this.cellToHash(cell);
    if (this.cells[h]) {
      delete this.cells[h];
      this.numCells--;
    }
  }

  dispose() {
    this.cells = null;
    this.numCells = 0;
    this.cellShape = null;
    this.cellGeo.dispose();
    this.cellGeo = null;
    this.cellShapeGeo.dispose();
    this.cellShapeGeo = null;
    this.list = null;
    this.vec3 = null;
    this.conversionVec = null;
    this.geoCache = null;
    this.matCache = null;
  }
  cubeRound(cel: Cell) {
    let rx = Math.round(cel.q);
    let ry = Math.round(cel.r);
    let rz = Math.round(cel.s);

    const xDiff = Math.abs(rx - cel.q);
    const yDiff = Math.abs(ry - cel.r);
    const zDiff = Math.abs(rz - cel.s);

    if (xDiff > yDiff && xDiff > zDiff) {
      rx = -ry - rz;
    } else if (yDiff > zDiff) {
      ry = -rx - rz;
    } else {
      rz = -rx - ry;
    }

    return this.cel.set(rx, ry, rz);
  }
}

export enum GridType {
  HEX,
  SQR, // square
  ABS // abstract
}
